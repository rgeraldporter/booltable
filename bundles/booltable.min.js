!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define("BoolTable",[],r):"object"==typeof exports?exports.BoolTable=r():e.BoolTable=r()}(window,function(){return function(e){var r={};function t(o){if(r[o])return r[o].exports;var n=r[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=r,t.d=function(e,r,o){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var n in e)t.d(o,n,function(r){return e[r]}.bind(null,n));return o},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){"use strict";Object.defineProperty(r,"__esModule",{value:!0});const o=t(1),n=e=>!(!Array.isArray(e)||!e.length)&&e.some(e=>e),a=e=>!(!Array.isArray(e)||!e.length)&&e.every(e=>e),i=e=>!(!Array.isArray(e)||!e.length)&&new Set(e).size>1,s=e=>!(!Array.isArray(e)||!e.length)&&e.every(e=>!e),l=e=>({map:r=>l(r(e)),chain:r=>r(e),ap:r=>r.map(e),inspect:()=>`Truth(${e})`,join:()=>e,concat:r=>r.chain(r=>l(e.concat(r))),head:()=>Array.isArray(e)&&e.length?e[0]:[],tail:()=>Array.isArray(e)&&e.length?e[e.length-1]:[],isEmpty:()=>Boolean(!Array.isArray(e)||0===e.length),or:()=>n(e),and:()=>a(e),nor:()=>s(e),xor:()=>i(e),forkOr:(r,t)=>n(e)?t():r(),forkAnd:(r,t)=>a(e)?t():r(),forkXor:(r,t)=>i(e)?t():r(),forkNor:(r,t)=>s(e)?t():r()}),c={of:e=>Array.isArray(e)?l(e):(e=>(console.error("Decision must be passed parameters that adhere to the documented type. Value that was passed:",e),l([!1])))(e)};r.Truth=c;const p=e=>o.Maybe.of(e.find(e=>e[0])).map(e=>e[1](e[2])),f=e=>o.Maybe.of(e.slice().reverse().find(e=>e[0])).map(e=>e[1](e[2])),y=e=>o.Maybe.of(e.filter(e=>e[0])).map(e=>e.map(e=>e[1](e[2]))),u=e=>o.Maybe.of(e.find(e=>e[0])).map(e=>e[1]),d=e=>o.Maybe.of(e.slice().reverse().find(e=>e[0])).map(e=>e[1]),h=e=>o.Maybe.of(e.filter(e=>e[0])).map(e=>e.map(e=>e[1])),m=(e,r)=>{const t=[[3===r[0].length&&"first"===e,p],[3===r[0].length&&"last"===e,f],[3===r[0].length&&"any"===e,y],[3===r[0].length&&"number"==typeof e,(e=>r=>o.Maybe.of(r.filter(e=>e[0])).map(r=>r.slice(0,e)).map(e=>e.map(e=>e[1](e[2]))))(e)],["first"===e,u],["last"===e,d],["any"===e,h],[isFinite(e),(e=>r=>o.Maybe.of(r.filter(e=>e[0])).map(r=>r.slice(0,e)).map(e=>e.map(e=>e[1])))(e)]].find(e=>e[0]);return o.Maybe.of(t).fork(()=>console.error("condition table is broken"),e=>e[1](r))},b=e=>({map:r=>b(r(e)),chain:r=>r(e),ap:r=>r.map(e),inspect:()=>`Decision(${e})`,join:()=>e,concat:r=>r.chain(r=>b(e.concat(r))),head:()=>e[0],tail:()=>e[e.length-1],isEmpty:()=>Boolean(0===e.length),run:(r="first")=>m(r,e)}),g={of:e=>Array.isArray(e)&&Array.isArray(e[0])&&e[0].length>1&&e[0].length<4?b(e):(e=>(console.error("Decision must be passed parameters that adhere to the documented type. Value that was passed:",e),b([[!0,null]])))(e)};r.Decision=g;const A=e=>r=>o.Maybe.of(((e,r)=>r.find(r=>r[0]===e))(r,e)).map(e=>e.slice(-1).pop()).fork(e=>(console.warn("`if` condition not found: ",r),!1),e=>Boolean(e)),j=e=>({map:r=>j(r(e)),chain:r=>r(e),ap:r=>r.map(e),inspect:()=>`BoolTable(${e})`,join:()=>e,concat:r=>r.chain(r=>j(e.concat(r))),head:()=>Array.isArray(e)&&e.length?e[0]:[],tail:()=>Array.isArray(e)&&e.length?e[e.length-1]:[],isEmpty:()=>Boolean(!Array.isArray(e)||0===e.length),q:A(e),query:A(e)}),M={of:e=>Array.isArray(e)&&Array.isArray(e[0])&&2===e[0].length?j(e):(e=>(console.error("BoolTable must be passed parameters that adhere to the documented type. Value that was passed:",e),j([["there was a BoolTable type error",!0]])))(e)};r.BoolTable=M},function(e,r){const t=e=>({isJust:!0,isNothing:!1,inspect:r=>`Just(${e})`,map:r=>n.of(r(e)),ap:r=>r.map(e),chain:r=>r(e),join:r=>e,fork:(r,t)=>t(e),sequence:r=>e.map(n.of)}),o=e=>({isJust:!1,isNothing:!0,inspect:e=>"Nothing",map:e=>o(),ap:e=>o(),chain:e=>o(),join:e=>o(),fork:(e,r)=>e(),sequence:e=>e(o())}),n={of:e=>null===e||void 0===e?o():t(e)};e.exports={Maybe:n,Nothing:o,Just:t}}])});
//# sourceMappingURL=booltable.min.js.map